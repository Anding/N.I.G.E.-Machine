#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 3.5cm
\rightmargin 3cm
\bottommargin 3.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Optimizing memory access design for a 32 bit FORTH processor
\end_layout

\begin_layout Date
June 2013
\end_layout

\begin_layout Author
Andrew Read
\end_layout

\begin_layout Address
\noindent
\align center
andrew81244@outlook.com
\end_layout

\begin_layout Abstract
This paper compares and contrasts two alternative approaches to designing
 system memory access for a 32 bit FORTH processor.
 One approach maximizes clock speed whilst the other maximizes instruction
 throughput.
 Each approach is found to have advantages and disadvantages.
 The project's conclusion is that a hybrid memory access design that considers
 the differing needs of the CPU control unit and datapath is likely to be
 the optimum performance strategy for a FORTH machine.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The N.I.G.E.
 Machine is a complete computer system implemented on an FPGA development
 board 
\begin_inset CommandInset citation
LatexCommand cite
key "Video 1"

\end_inset

.
 It comprises a 32 bit softcore processor optimized for the FORTH language,
 a set of peripheral hardware modules, and FORTH system software.
 The system is primarily designed to support the rapid prototyping of experiment
al scientific apparatus.
 The N.I.G.E.
 Machine was first presented in a paper at EuroFORTH 2012 
\begin_inset CommandInset citation
LatexCommand cite
key "EF2012"

\end_inset

.
 In the conclusions of that paper a number of avenues for further work were
 suggested.
 These included improving the bandwidth between the CPU and system memory,
 implementing an SD-card interface with a FAT file system, and porting the
 N.I.G.E.
 Machine to a higher performance FPGA development board.
 
\end_layout

\begin_layout Standard
As of the date of this paper an SD-card interface, native FAT file system,
 and FORTH File-Access wordset have been successfully implemented and tested.
 This greatly simplifies the transfer of program and data files between
 the N.I.G.E.
 Machine and a PC.
 The upgrade was relatively straightforward and did not raise substantial
 new design issues.
 Porting the N.I.G.E.
 Machine to a Digilent Atlys development board with a Spartan 6 FPGA is
 currently underway.
 
\end_layout

\begin_layout Standard
The goal of improving memory access bandwidth was set with the intention
 of redesigning the connection between the system memory (i.e.
 FPGA Block RAM, 
\begin_inset Quotes eld
\end_inset

SRAM
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
In this paper and the N.I.G.E.
 Machine documentation, Block RAM that is used for system memory is given
 the term 
\begin_inset Quotes eld
\end_inset

SRAM
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

) and the softcore CPU.
 The CPU is a 32 bit processor, but the memory databus between the CPU and
 system memory is only 8 bits wide in the original N.I.G.E.
 Machine design (fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:system8"

\end_inset

).
 Widening the databus from 8 bits to 32 bits to match the width of the softcore
 processor might initially seem to be a worthwhile and simple capacity increase
 at the cost of some further FPGA resources.
 However upon closer examination this design change actually raises a number
 of interesting implications in terms of conflicting requirements for functional
ity.
 As a result, the final preference between the 8 bit and 32 bit memory databus
 configurations requires deeper consideration of the intended application
 and the specific hardware on which the N.I.G.E.
 Machine will be deployed.
 
\end_layout

\begin_layout Standard
Using the N.I.G.E.
 Machine as an example, this paper explains the background and challenges
 in optimizing memory access for a 32 bit FORTH processor.
 The problems faced are not new and would be recognizable to any processor
 designer.
 The paper seeks to advance the state of the art in softcore FORTH systems
 by providing a systematic, evidence-based report with detailed implementation
 information.
 
\end_layout

\begin_layout Standard
The structure of the paper is as follows.
 First of all the memory access requirements of a FORTH processor are discussed
 on a qualitative level (section 2).
 This section also introduces the general tradeoffs between an 8 bit and
 a 32 bit system memory databus.
 The 32 bit databus design that was successfully implemented on the N.I.G.E.
 Machine is described next (section 3).
 Performance benchmark comparisons between the 8 bit and 32 bit databus
 configurations of the N.I.G.E.
 Machine are presented (section 4).
 In the light of the performance benchmarking results there is a discussion
 about the tradeoff decisions guiding which implementation should ultimately
 be preferred (section 5).
 The conclusion attempts to synthesize the experience with the N.I.G.E.
 Machine into lessons for FORTH processors in general and suggests avenues
 for further work (section 6).
\end_layout

\begin_layout Standard
All of the N.I.G.E.
 Machine design files and software are available open source 
\begin_inset CommandInset citation
LatexCommand cite
key "Github"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename EF2013 figures/System diagram 8.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:system8"

\end_inset

N.I.G.E.
 Machine system diagram showing the principal components and CPU connections.
 This is the 8 bit databus configuration (highlighted), as presented at
 EuroFORTH 2012.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Memory access requirements of a FORTH processor
\end_layout

\begin_layout Subsection
Review of prior work
\end_layout

\begin_layout Standard
A number of softcores have been designed specifically to execute FORTH 
\begin_inset CommandInset citation
LatexCommand cite
key "Bowman,Microcore,b16,EP32,Novix NC4000,Rible"

\end_inset

.
 Several aspects of the J1 
\begin_inset CommandInset citation
LatexCommand cite
key "Bowman"

\end_inset

 directly inspired the design of the N.I.G.E.
 Machine.
 In most of these examples the focus of the design work has been the CPU
 itself while memory access requirements have been less of a consideration.
 There have been some notable exceptions.
 For example the RTX 2000 includes an on-chip memory page controller that
 considerably enhances memory access 
\begin_inset CommandInset citation
LatexCommand cite
key "Koopman"

\end_inset

, and Klaus Schleisiek's microcore 
\begin_inset CommandInset citation
LatexCommand cite
key "Microcore"

\end_inset

 features pre-incrementing and post-incrementing data memory operations
 (++!, !++, ++@, @++) that are directly supported by hardware.
 Another approach to improving memory access efficiency is to pack more
 instructions per unit of data.
 For example Bernd Paysan's b16 processor
\begin_inset CommandInset citation
LatexCommand cite
key "b16"

\end_inset

 packs 3 instructions into a 16 bit word.
 
\end_layout

\begin_layout Standard
Philip Koopman 
\begin_inset CommandInset citation
LatexCommand cite
key "Koopman"

\end_inset

, in discussing the characteristics of 16 bit stack machines, makes the
 point that the fit between the width of the CPU datapath and the FORTH
 programming model is a key design factor.
 Koopman observes that an 8 bit CPU is likely be unsatisfactory from a performan
ce standpoint because too much time would be required in synthesizing 16
 bit operations, whilst at the time of writing (1989), specifying a 32 bit
 CPU might be too expensive.
 The reasonable assumption being made here is that wider datapaths can also
 access memory across wider databuses, thus increasing processing bandwidth.
\end_layout

\begin_layout Standard
Koopman also discusses the limits of memory bandwidth.
 He makes the point that traditional, register-based processors are very
 dependent on cache memory.
 This creates performance bottlenecks that are subject to the hit ratios
 of various caches, and the organization of the code produced by the compiler.
 He envisages stack machines offering an alternative approach to memory
 organization because of their very fast procedure calls.
 (Procedure calls are fast on stack machines because there is no need to
 save a register set in system memory).
 In the stack machine approach, frequently executed code can be stored in
 on-chip memory, avoiding the requirement for dynamic memory management.
 The design of N.I.G.E.
 Machine follows the approach envisioned by Koopman in that code density
 is very high, and system memory comprises FPGA static RAM (Block RAM) that
 can be accessed in a single clock cycle.
 
\end_layout

\begin_layout Standard
This paper builds on Koopman's theme of efficient memory access to focus
 on the specific problem of how best to design the connection between the
 CPU and system memory on a 32-bit FORTH machine.
 The first question to answer is, what are the memory access requirements
 of a 32 bit FORTH processor?
\end_layout

\begin_layout Subsection
Impact of system design objectives on memory access requirements
\end_layout

\begin_layout Standard
A FORTH processor has some distinct advantages in real-time control applications
 
\begin_inset CommandInset citation
LatexCommand cite
key "Pelc,Koopman"

\end_inset

.
 The design objectives of the N.I.G.E.
 Machine reflect its intended role in the real time control of scientific
 hardware.
 The principal objectives are listed below and are in turn the main influence
 on memory access requirements.
\end_layout

\begin_layout Description
Deterministic
\begin_inset space \space{}
\end_inset

execution.
 Avoiding jitter in electronic interfaces is an essential real time requirement
 for precise control and measurement.
 This necessitates that the softcore CPU is designed so that any given instructi
on will alway execute in a certain number clock cycles, including instructions
 that access system memory.
 
\end_layout

\begin_layout Description
High
\begin_inset space \space{}
\end_inset

instruction
\begin_inset space \space{}
\end_inset

throughput.
 High instruction throughput translates directly into higher processing
 performance and shorter interrupt response times.
 This is especially important on FPGA softcore processors that operate at
 lower clock rates than comparable dedicated microcontrollers.
 Throughput of once instruction per clock cycle is the ideal target.
\end_layout

\begin_layout Description
Maximum
\begin_inset space \space{}
\end_inset

code
\begin_inset space \space{}
\end_inset

density.
 The fastest memory resource available to a softcore CPU is FPGA Block RAM.
 Block RAM also has the advantage over external memory of deterministic
 access (i.e.
 guaranteed single clock cycle read/write).
 However Block RAM resources are typically limited to several tens or hundreds
 of kilobytes.
 To maximize the use of Block RAM as program memory, code density needs
 to be as high as possible.
 Ideally instructions should be encoded in no more than a single byte.
\end_layout

\begin_layout Description
Flexible
\begin_inset space \space{}
\end_inset

memory
\begin_inset space \space{}
\end_inset

access.
 With a 32 bit processor, optimizing the speed and flexibility of memory
 access requires that CPU instructions are available that read or write
 memory in byte, 16 bit, and 32 bit formats.
 Flexibility is further enhanced if even address alignment is not required
 when accessing 16 bit or 32 bit data in  system memory.
\end_layout

\begin_layout Subsection
Advantages and limitations of an 8 bit wide databus
\end_layout

\begin_layout Standard
Block RAM can be configured in a variety of formats by specifying (with
 the FPGA design tools) the width (i.e.
 data size: 8 bits, 16 bits, etc.) and depth (i.e.
 number of address lines) of the required memory resource.
 The N.I.G.E.
 Machine's softcore is a 32 bit CPU, but the system presented at EuroFORTH
 2012 incorporated system memory configured in an 8 bit wide format.
 Coupling the 8 bit wide Block RAM to the CPU in this design is an 8 bit
 databus and an address bus that references memory byte-by-byte (fig 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:system8"

\end_inset

).
 
\end_layout

\begin_layout Standard
This configuration has some advantages: an 8 bit databus naturally facilitates
 the fetching of single byte instructions, and a byte-by-byte address format
 avoids misaligned address boundaries.
 The design of separate CPU instructions that read or write memory in byte,
 16 bit, or 32 bit formats is also easily facilitated in this configuration
 by arranging for the CPU control unit to read or write byte data from/to
 consecutive memory locations in consecutive CPU clock cycles, as required
 by the length of the data.
\end_layout

\begin_layout Standard
In conjunction with the N.I.G.E.
 Machine's three stage pipeline 
\begin_inset CommandInset citation
LatexCommand cite
key "EF2012"

\end_inset

, the 8 bit databus configuration provides straightforward memory access
 and throughput of one instruction per clock cycle for almost all instructions.
 The important exceptions are those instructions that require access to
 more than a single byte of memory and which therefore require more than
 one cycle to execute.
 These include all of the load literal instructions and the word and longword
 memory fetch and store instructions.
\end_layout

\begin_layout Standard
This impact of this limitation becomes apparent when considering the relative
 frequency of instructions that comprise the FORTH system software (table
 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:EF2012instructionfreq"

\end_inset

).
 The most common instruction, which occurs almost twice as frequently as
 any other, is LOAD.W (or 
\begin_inset Quotes eld
\end_inset

#.W
\begin_inset Quotes erd
\end_inset

), the instruction to load a 16 bit literal to the stack.
 The ubiquity of the LOAD.W instruction in the FORTH system software reflects
 the load/store architecture of a stack machine CPU and the subroutine threaded
 nature of FORTH (LOAD.W is the instruction used to load a subroutine address
 prior to a JSR (jump to subroutine)).
 In the N.I.G.E.
 Machine instruction format, LOAD.W is a three byte instruction comprising
 an opcode byte followed by the high and low data bytes in big endian format.
 It takes three CPU clock cycles to execute with an 8 bit databus configuration.
 On account of the narrow instruction fetch, the most commonly executed
 instruction is therefore one of the minority of instructions that have
 low throughput (less than one instruction per clock cycle).
 This is a defeat of the optimization maxim, 
\begin_inset Quotes eld
\end_inset

make the common case fast
\begin_inset Quotes erd
\end_inset

, and was the key motivation to consider the design of a wide (32 bit) memory
 databus.
 
\end_layout

\begin_layout Standard
(Looking ahead, a 32 bit memory databus also allows the development of a
 new jump-to-subroutine instruction (JSL) that takes a 24 bit immediate
 literal target.)
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Instruction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Frequency
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOAD.W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17.88%
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JSR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.17%
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RTS and ,RTS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.06%
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOAD.B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.47%
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:EF2012instructionfreq"

\end_inset

The most used CPU instructions in the FORTH system software in the 8 bit
 databus configuration of the N.I.G.E.
 Machine that was presented at EuroFORTH 2012.
 The most frequently used instruction, LOAD.W, is one of the minority of
 instructions that have low throughput (less than one instruction per clock
 cycle).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Design complications resulting from a 32 bit wide databus
\end_layout

\begin_layout Standard
When Block RAM is configured in longword (32 bit) data format, each memory
 address references a separate, complete longword.
 Consecutive memory addresses therefore step through memory in units of
 4 bytes at each increment.
 The first concern in designing a wider databus are the mismatches that
 arise between the 4 byte wide data format and the width of each instruction
 (1 byte) and the smallest unit of memory access (also 1 byte).
 These mismatches have a number of important design implications.
\end_layout

\begin_layout Standard
The first implication is that the address bus cannot directly reference
 memory at the level of individual bytes or 16 bit words.
 This is at odds with the design requirement that the CPU should be able
 to read or write to memory either longwords, words or bytes.
 For memory read instructions this problem can be circumvented by creating
 a composite address bus whereby the high bits of the composite address
 bus are matched directly with the Block RAM address bus, and the low 2
 bits are used to multiplex individual bytes from within the relevant longword
 (fig 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:read 8 from 32"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename EF2013 figures/Block diagrams.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:read 8 from 32"

\end_inset

Illustrative scheme for reading individual bytes from 32 bit width RAM.
 There is no equivalently simple, single step scheme for writing individual
 bytes to 32 bit width RAM.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

For write instructions there is, however, no simple solution because when
 configured in longword format, FPGA Block RAM writes complete longwords
 without the flexibility to specify only individual words or bytes within
 them.
 (Note however that a full review of alternative FPGA device families was
 not made and this limitation may not apply to higher-end or more recent
 devices.)
\end_layout

\begin_layout Standard
The second implication is the problem of address boundaries.
 Suppose that the CPU wishes to read 4 consecutive bytes from memory.
 Two different situations arise (fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:misaligned"

\end_inset

).
 In the first case, the address of the first byte happens to coincide with
 a longword address within memory.
 This is aligned access and can be accomplished with a single read instruction
 to that memory address, with a duration of one clock cycle.
 However in the second case, the desired 4 bytes may be spread across two
 consecutive longword addresses in memory.
 This is non-aligned access and it requires the CPU to execute two read
 instructions from the two consecutive memory addresses, thus taking two
 clock cycles.
 Either that, or non-aligned access must be prohibited by the CPU specification.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename EF2013 figures/misaligned access.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:misaligned"

\end_inset

Aligned and non-aligned memory access operations require different treatment.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Neither of these constraints are attractive.
 Prohibiting non-aligned memory access, especially at the longword level,
 decreases the flexibility available to the programmer and the FORTH compiler,
 and wastes space in memory.
 Requiring the CPU to switch between single cycle and two cycle memory access
 modes depending on address alignment would mean that instruction execution
 would no longer be deterministic, thus introducing jitter into signals
 being generated in real time.
 Fixing the duration all memory read accesses at the worst case of two-cycles
 would solve the problem of non-deterministic execution, but at the expense
 of halving the throughput of all load/store instructions.
\end_layout

\begin_layout Standard
These issues are a particular concern for FORTH processors for the reasons
 mentioned earlier.
 The real-time control applications of a FORTH processor mean that deterministic
 execution is often sacrosanct.
 At the same time, FPGA based softcore processors are inevitably clocked
 a much lower frequencies than general purpose CPU's and so high instruction
 throughput is essential.
 FPGA Block RAM is also usually limited to tens or hundreds of kilobytes
 and FORTH has a natural advantage in the very small code size of its applicatio
ns compared with other high level languages.
 For memory efficiency reasons, byte level memory access and byte sized
 instruction coding is therefore also highly desirable.
\end_layout

\begin_layout Standard
Fortunately by leveraging a particular capability of FPGA Block RAM it is
 possible to design a 32 bit wide memory architecture which circumvents
 almost all of these constraints.
 That FPGA Block RAM feature is 
\series bold
dual ported memory access
\series default
.
 It is possible to configure FPGA Block RAM with two independent address
 and data buses that read or write to separate memory locations in the same
 clock cycle.
 (In the Xilinx Spartan 3 FPGA family dual ported Block RAM memory access
 is a standard feature available at no additional cost, however a full review
 was not made to determine if that also generally applies to other device
 families.) The 32 bit N.I.G.E.
 Machine memory architecture leverages dual ported Block RAM to provide
 a 32 bit wide memory databus whilst maintaining byte level memory access,
 deterministic execution and single cycle throughput for most instructions.
 
\end_layout

\begin_layout Section
Design for 32-bit wide system memory access
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:system32"

\end_inset

 shows the N.I.G.E.
 Machine system diagram in 32 bit databus configuration.
 The design is described in detail below.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename EF2013 figures/System diagram 32.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:system32"

\end_inset

N.I.G.E.
 Machine system diagram showing the principal components and CPU connections.
 This is the 32 bit databus configuration, as highlighted.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SRAM memory controller
\end_layout

\begin_layout Standard
The key component in the N.I.G.E.
 Machine's 32 bit memory datapath is the SRAM controller that sits between
 the CPU and dual-ported SRAM, as shown in fig 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Controller block"

\end_inset

.
 It provides byte, word and longword read/write access to system memory.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename EF2013 figures/SRAM controller.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Controller block"

\end_inset

Block diagram of the SRAM memory controller showing the connection to dual
 ported Block RAM
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Read functionality
\end_layout

\begin_layout Standard
The functionality of the SRAM controller during a memory read is shown in
 fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SRAM controller function"

\end_inset

.
 The memory address provided by the CPU points to an individual byte address
 in memory.
 The SRAM controller splits this address into two parts: the lowest 2 address
 bits and the remaining (high) address bits.
 The high address bits point to the longword address within which the selected
 byte address lies.
 The lowest 2 address bit can be interpreted as the offset of the byte address
 from the zeroth byte of the longword address.
 The SRAM controller passes the high address bits directly to SRAM port
 A.
 It also adds 1 to the high bits address (equivalent to adding 4 to the
 byte level address) and passes this address to SRAM port B.
 One clock cycle later, the SRAM read operations occur on both ports simultaneou
sly, and the SRAM controller will have a total of eight contiguous bytes
 available to it from SRAM ports A and B combined.
 The offset multiplexer selects four contiguous bytes out of these eight
 according to the lowest 2 bits of the address specified by the CPU.
 Finally, the size multiplexer takes a 2 bit control signal from the CPU
 control unit and selects either a single byte, a single word, or the full
 longword from the output of the offset multiplexer.
 In the case of selecting a byte or a longword, the multiplexer shifts the
 relevant bits to the low end of the output longword and pads the high end
 with zero.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename EF2013 figures/SRAM controller multiplexers.eps

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:SRAM controller function"

\end_inset

Details of the SRAM controller read functionality.
 The offset multiplexer select the appropriate longword from the 8 bytes
 available from SRAM ports A and B.
 The length multiplexer either passes through the longword or left pads
 a word or byte output with zero bits, according to the selected size.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:controller examples"

\end_inset

 illustrates some worked examples of the SRAM controller read functionality.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="1.5cm">
<column alignment="center" valignment="top" width="1.5cm">
<column alignment="center" valignment="top" width="2cm">
<column alignment="center" valignment="top" width="1.5cm">
<column alignment="center" valignment="top" width="1.5cm">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="3cm">
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
CPU address
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
CPU size request
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Port A address
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Port B address
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Offset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory bytes at output
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
longword
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
[00][01][02][03]
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
word
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
[--][--][00][01]
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
longword
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
[07][08][09][10]
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
[--][--][--][07]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:controller examples"

\end_inset

Worked examples of SRAM controller read functionality.
 In case (A) the CPU is reading a longword from memory address 0.
 The first four bytes in memory appear at the output, in big endian format.
 In the case (B), the CPU is also reading from memory address zero, but
 a word.
 In this case the size multiplexer has shifted the word at memory address
 zero to the low end of the output databus and filled the high bits with
 zero (indicated [--] in the table).
 Cases (C) and (D) illustrate a read from memory address 7.
 In these cases port A reads longword memory address 1 (byte memory address
 4) and port B reads longword memory address 2 (byte memory address 8).
 The offset of 3 selects a longword starting at third byte on port A.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Write functionality
\end_layout

\begin_layout Standard
The functionality of the SRAM controller during memory write mode is shown
 in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SRAM write"

\end_inset

.
 Essentially a write to SRAM now takes place over two cycles, during which
 time the CPU must hold the address and data constant on the memory bus.
 In the first cycle, the existing contents of SRAM memory at the relevant
 addresses are read and multiplexed with the write data from the CPU.
 Multiplexing takes into account both the memory address offset, and the
 size of the data being presented by the CPU (longword, word, byte).
 The result is that the appropriate overlay of the CPU write data onto the
 existing memory contents becomes available at the end of the first cycle.
 In the second cycle the outputs of the multiplexers are written to SRAM.
 
\end_layout

\begin_layout Standard
As with SRAM read functionality both of the dual SRAM ports are active.
 The low two bits of the address presented by the CPU form the address offset
 used by the multiplexers, while the high address bits are used to access
 two consecutive longwords in SRAM.
 A single cycle delay on the write enable signal from the CPU defers the
 SRAM write to the second cycle.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename EF2013 figures/SRAM write.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:SRAM write"

\end_inset

Details of SRAM controller write functionality.
 A write operation takes place over two cycles.
 In the first cycle the existing memory contents are read and overlaid at
 the appropriate position with the data from the CPU.
 In the second cycle the memory contents are updated.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Dual data output
\end_layout

\begin_layout Standard
In addition to providing non-aligned (byte addressable) longword access
 for any given memory address, the SRAM controller is also configured to
 output the memory contents at the next following address.
 This databus is labeled 
\begin_inset Quotes eld
\end_inset

Data (addr + 1)
\begin_inset Quotes erd
\end_inset

 in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Controller block"

\end_inset

.
 The purpose of this data is to expedite the execution of load literal CPU
 instructions.
 The format of a load literal instruction is a single instruction byte followed
 by a longword, word, or byte of data.
 By making available to the CPU the contents at the next memory address
 beyond the current instruction, the literal data can be multiplexed directly
 into the datapath during single cycle execution of a load literal instruction.
\end_layout

\begin_layout Subsection
Datapath
\end_layout

\begin_layout Standard
Minimal changes were required to the CPU datapath design to accommodate
 the 32 bit memory databus since the datapath width is already 32 bits.
 
\end_layout

\begin_layout Standard
In the 8 bit databus configuration of the N.I.G.E.
 Machine, memory read data is made available to the 32 bit datapath on a
 32 bit accumulator register that is managed by the control unit finite
 state machine.
 The register functions to accumulate the required data byte by byte over
 the required number of memory read clock cycles.
 In the 32 bit databus design memory the accumulator is not required because
 32 bit data is available directly from the SRAM controller.
 
\end_layout

\begin_layout Standard
The datapath also has direct access to the Block RAM's that hold the parameter
 and return stacks.
 The stack databuses are always 32 bits wide.
 The memory holding the parameter and return stacks is dual ported and is
 also available to the CPU over the system memory databus.
 When Block RAM is configured with a 32 bit databus on one port (in this
 case for direct stack access) and with an 8 bit databus on the other port
 (in this case for system memory access in 8 bit databus format) the Xilinx
 memory layout is little endian by default.
 The N.I.G.E.
 Machine is big endian format and hence the 4 bytes of the longword must
 be reversed when read over the stack databus.
 This is a minor detail that does not affect performance, but the complexity
 is avoided in the 32 bit databus configuration.
\end_layout

\begin_layout Subsection
Control unit
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename EF2013 figures/offset.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:offset"

\end_inset

Identification of the next instruction byte on the databus by the program
 counter logic.
 In case (A) there is no currently executing instruction and the offset
 to the next instruction is zero.
 The next instruction is a load literal byte instruction of length 2.
 In case (B) the currently executing instruction is one byte in length and
 the offset to the next instruction is one byte.
 In case (C) the currently executing instruction is a load literal byte
 instruction of length 2 bytes, and this is also the offset to the next
 instruction.
 Case (D) illustrates that when the currently executing instruction is load
 literal longword of length 5 the next instruction lies beyond the width
 of the 4 byte databus and the offset cannot be calculated.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The control unit required a more considerable redesign to accommodate the
 32 bit databus and optimize instruction execution.
\end_layout

\begin_layout Subsubsection
Program counter logic
\end_layout

\begin_layout Standard
The principal impact of the 32 bit memory datapath on the control unit is
 that the program counter (
\begin_inset Quotes eld
\end_inset

PC
\begin_inset Quotes erd
\end_inset

) logic needs to be reconfigured to process variable length instructions
 that execute in a single cycle.
 In the N.I.G.E.
 Machine instruction set instructions longer than a single byte only occur
 when literal data is provided in the second and subsequent bytes (the instructi
on itself is always fully specified by the initial byte).
 These include the load literal and branch instructions.
 
\end_layout

\begin_layout Standard
In the 8 bit databus configuration, variable length instructions are executed
 over several cycles with each successive instruction byte being read from
 memory in successive cycles.
 The program counter is therefore hardwired to step in units of a single
 byte in all circumstances except when a branch or jump occurs.
 This considerably simplifies the program counter control logic.
 In the 32 bit datapath format, instructions that are longer than one byte
 and which include literal data also need to be executed in a single cycle.
 Therefore the program counter logic must decode the length of each instruction
 and advance by the relevant number of bytes during a single cycle.
 This process for PC update is as follows (fig 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:offset"

\end_inset

).
\end_layout

\begin_layout Standard
Firstly the program counter logic must determine the location of the next
 instruction (i.e.
 the instruction that will be executed after the currently executing instruction
).
 The control unit is configured so that the currently executing instruction
 is always found as the byte at the lowest memory address on the 32 bit
 datapath.
 (This is the highest order byte of the whole longword on a big endian machine
 such as the N.I.G.E.
 Machine.) The size of the currently executing instruction is also always
 known to the control unit finite state machine and made available as an
 output (labeled as the 
\begin_inset Quotes eld
\end_inset

offset
\begin_inset Quotes erd
\end_inset

, fig 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:offset"

\end_inset

).
 The program counter logic refers to the offset to identify which byte of
 the longword corresponds to the next instruction.
 For example, the majority of instructions are encoded as single bytes and
 so the next instruction is the next byte.
 The load literal byte and word instructions are two or three bytes in length
 respectively and so the next instruction is two or three bytes ahead respective
ly.
 Offsets are not calculated for branch or jump instructions since these
 require that the PC be diverted rather than incremented.
\end_layout

\begin_layout Standard
Once the instruction byte of the next instruction has been identified, that
 instruction byte is multiplexed to the second stage of the PC logic which
 determines the instruction length.
 Finally, in the third stage of the PC logic, the length of the next instruction
 is added to the current value of the PC, so the the PC will be appropriately
 updated in the next cycle.
\end_layout

\begin_layout Subsubsection
Four stage pipeline
\end_layout

\begin_layout Standard
Implementation of the program counter logic is made more complex by the
 fact that the N.I.G.E.
 Machine CPU is a pipelined design.
 As a result the program counter needs to decode the instruction length
 before, and independently of, the rest of the instruction execution logic.
 This requires an extra stage at the beginning of the pipeline, which is
 now 4 stages long as illustrated in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Illustration-pipe"

\end_inset

.
 The pipeline stages are:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="6">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="1cm">
<column alignment="center" valignment="top" width="1cm">
<column alignment="center" valignment="top" width="1cm">
<column alignment="center" valignment="top" width="1cm">
<column alignment="center" valignment="top" width="1cm">
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Component / clock cycle
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Cycle #0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Cycle #1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Cycle #2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Cycle #3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Cycle #4
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Program counter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Offset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Next instruction byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
53
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Length of next instruction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instruction byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
53
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opcode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
53
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Microcode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1191
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Datapath combinatorial logic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
255
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Datapath synchronous logic register
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
255
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Illustration-pipe"

\end_inset

Illustration of the execution pipeline for the CPU instruction to load a
 literal byte with value 255.
 Executing variable length instructions in a single cycle requires an extra
 stage in the pipeline (clock cycle #1 in this illustration).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

READ INSTRUCTION SIZE
\begin_inset Quotes erd
\end_inset

.
 In the example of fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Illustration-pipe"

\end_inset

 the pipeline is being started afresh (following a jump, branch or reboot)
 and there is no currently executing instruction.
 The 
\begin_inset Quotes eld
\end_inset

offset
\begin_inset Quotes erd
\end_inset

 is therefore zero.
 During clock cycle #1 the PC logic identifies the next instruction byte
 according to the scheme described above.
 In this case 53, corresponding to the load literal byte instruction which
 is 2 bytes long.
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

FETCH OPCODE
\begin_inset Quotes erd
\end_inset

.
 On the rising edge of clock cycle #2, SRAM system memory reads the instruction
 byte at the current PC address and extracts its opcode.
 A 
\begin_inset Quotes eld
\end_inset

new
\begin_inset Quotes erd
\end_inset

 PC address is determined by adding to the PC the instruction size increment
 calculated in the previous cycle, in this case 2 bytes.
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

DECODE AND COMPUTE
\begin_inset Quotes erd
\end_inset

.
 On the rising edge of clock cycle #3, SRAM microcode memory within the
 control unit takes the opcode as a lookup address and returns the corresponding
 microcode value (1191).
 During the same clock cycle the combinatorial logic in the datapath is
 configured according to the microcode value through its control signals.
 The value of the datapath computation becomes available as the combinatorial
 output, in this example the literal value loaded is 255.
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

SAVE
\begin_inset Quotes erd
\end_inset

.
 On the rising edge of clock cycle #4, the output of the datapath in combinatori
al logic (i.e.
 the result of the computation in the previous pipeline stage) is written
 into the synchronous logic register that holds the value of the top of
 stack.
\end_layout

\begin_layout Subsubsection
Instruction throughput
\end_layout

\begin_layout Standard
The number of clock cycles required to execute each instruction in both
 the 8 bit and 32 bit databus configurations of the N.I.G.E.
 Machine is scheduled in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Clock-cycles"

\end_inset

.
 The differences in throughput between the two configurations results from
 two opposing factors.
 (i) The 32 bit databus configuration reduces the number of clock cycle
 required to execute instructions that load, fetch, or save access word
 and longword data in SRAM system memory because of the greater bandwidth.
 However, (ii) the additional pipeline stage adds an extra cycle to all
 instructions that require the restart of the pipeline.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="16" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="2cm">
<column alignment="center" valignment="top" width="2cm">
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Instruction 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Mnemonic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Cycle count
\begin_inset Newline newline
\end_inset

 (8 bit databus)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Cycle count
\begin_inset Newline newline
\end_inset

 (32 bit databus)
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Load literal byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOAD.B (or #.B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Load literal word
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOAD.W (or #.W)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Load literal longword*
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOAD.L (or #.L)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Branch (conditional or unconditional)*
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BEQ / BRA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Jump to subroutine (address on stack)*
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JSR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Jump to subroutine (literal address)*
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JSL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n/a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Return from subroutine*
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RTS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fetch/store byte in SRAM*
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FETCH.B / STORE.B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fetch/store word in SRAM*
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FETCH.W / STORE.W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fetch/store longword in SRAM*
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FETCH.L / STORE.L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fetch/store in PSDRAM
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FETCH.[] / STORE.[]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
variable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
variable
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Multiply (signed/unsigned)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MULTS / MULTU
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Divide (signed/unsigned)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DIVS / DIVU
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
43/42
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
43/42
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
?dup
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IFDUP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
All other instructions
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Clock-cycles"

\end_inset

Clock cycles per instruction in the N.I.G.E.
 Machine softcore CPU in both 8 bit and 32 bit databus configurations.
 Instructions marked * require a restart of the pipeline following their
 execution.
 Most, but not all, instructions are faster in the 32 bit configuration.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following analysis of instruction throughput speaks from the perspective
 of the 32 bit datapath configuration and the changes made from the 8 bit
 format.
\end_layout

\begin_layout Itemize
The load literal byte and load literal word instructions now execute in
 a single cycle.
 However the load literal longword instruction actually requires two cycles
 to execute.
 This is because the length of that instruction (5 bytes) means that whilst
 it is being executed, the next instruction byte is not visible on the datapath
 to the PC update logic (fig 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:offset"

\end_inset

), and hence an extra cycle must be added with no instruction to restart
 the pipeline.
 
\end_layout

\begin_layout Itemize
Branches also require a restart of the pipeline because of the change to
 the PC.
 However the extra cycle this entails is offset by the fact that the whole
 two byte instruction can be read and decoded in a single cycle.
 As a result the total execution cycle count is unchanged at 3 cycles.
\end_layout

\begin_layout Itemize
The JSR instruction is now one cycle longer due to extra cycle to restart
 the pipeline.
 This might imply a considerable performance penalty in executing FORTH
 code, which is heavily subroutine dependent.
 However the 32 bit databus configuration permits the inclusion of a new
 instruction, JSL, that provides a considerable efficiency.
 This instruction is a 
\begin_inset Quotes eld
\end_inset

jump to subroutine
\begin_inset Quotes erd
\end_inset

 with the subroutine address specified as a 24 bit literal value.
 Previously, the typical FORTH code to execute a subroutine branch comprised
 (i) #.W, to load the subroutine address onto the stack, followed by (ii)
 JSR.
 This combination requires a total of 5 cycles.
 The JSL instruction accomplishes the same result in 3 cycles.
 However the advantage of 2 cycles on a subroutine call is offset by the
 fact that an RTS instruction is also one cycle longer due to the lengthened
 pipeline.
 The net difference is that subroutine calls are now one cycle faster overall.
 (As a side note, the introduction of the JSL instruction did not necessitate
 significant rewriting of the N.I.G.E.
 Machine system software.
 The system software is written in assembly language, and the macro assembler
 implements either style of subroutine call with a macro, 
\begin_inset Quotes eld
\end_inset

CALL
\begin_inset Quotes erd
\end_inset

, appropriate to whichever version of the hardware is being compiled for.)
\end_layout

\begin_layout Itemize
Fetches and stores to SRAM system memory of all datasizes now execute in
 three cycles, compared with two, three, and five cycles for byte, word
 and longword data previously.
 In FORTH terms, C@ and C! are slower than before, W@ and W! are unchanged,
 and @ and ! are faster than before.
\end_layout

\begin_layout Itemize
Other instructions that do not access SRAM system memory and do not restart
 the pipeline are unchanged.
 Fetch and store to the external pseudo-static dynamic RAM (
\begin_inset Quotes eld
\end_inset

PSDRAM
\begin_inset Quotes erd
\end_inset

) takes place through the PSDRAM controller and timing depends on the arbitratio
n of the bus with other users of PSDRAM memory such as the VGA controller.
\end_layout

\begin_layout Standard
In summary, whilst for most instructions the softcore CPU throughput has
 been increased in the 32 bit datapath design, it is clear that there have
 been tradeoffs in certain cases.
 To assess whether the 32 bit datapath configuration should be expected
 to lead to higher performance overall, it is also necessary to examine
 the frequency of instruction usage.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:instruction-frequency"

\end_inset

 schedule the most frequently used instructions in the N.I.G.E.
 Machine system software (i.e.
 the FORTH operating system).
 Despite the fact that some instructions are slower in the 32 bit datapath
 configuration, taking into account which instructions are most common,
 the data suggest that average instruction throughput should be improved
 in this configuration.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="2cm">
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Instruction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Frequency
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Clock cycle difference
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JSL 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.2% 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-2
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
#.W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.8%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-2
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RTS and ,RTS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8.7%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+1
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BRA and BEQ
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8.7%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
#.B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7.3%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-1
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DUP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.8%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DROP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.1%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FETCH.L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.5%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-2
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FALSE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.3%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SWAP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.3%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OVER
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.2%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
STORE.L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.1%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-2
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.6%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.6%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FETCH.B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.6%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+1
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.1%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
STORE.B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.9%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:instruction-frequency"

\end_inset

Relative instruction frequency for the 80% most common instructions in the
 N.I.G.E.
 Machine system software (counted by code frequency rather than execution
 frequency).
 The clock cycle difference values are the instruction duration difference
 in moving from the 8 bit to 32 bit databus configuration.
 Negative values indicate that the 32 bit configuration is faster.
 The most used instruction, JSL, is 2 cycles faster in the 32 bit databus
 configuration than the previous equivalent.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Subsection
Hardware implementation
\end_layout

\begin_layout Standard
Implementation of the 32 bit datapath format on the Nexys 2 FPGA development
 board proved more challenging than anticipated.
 Whilst synthesis was satisfactory in the electronic simulator, the new
 design was not able to complete place and route to meet the timing constraints
 of a 50MHz clock speed.
 This was in spite of considerable optimization work with the FPGA design
 tools.
 The reason for the slower timing in the 32 bit bus configuration was revealed
 by analyzing the place and route results and identifying the longest signal
 path.
 This signal path is the logic required to operate the variable instruction
 length program counter logic in the control unit.
 The steps involved are shown schematically in fig 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PC logic"

\end_inset

.
 As described in the section discussing the control unit, these steps are
 necessary if the N.I.G.E.
 Machine is to execute variable length instructions in a single clock cycle.
 
\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Best-achiveable"

\end_inset

 summarizes the best achievable timing of the N.I.G.E.
 Machine in both 8 bit and 32 bit databus formats.
 The best achievable clock frequency in 32 bit format was 44MHz.
 However it is not possible to operate the N.I.G.E.
 Machine at arbitrary clock frequencies (say 40MHz), because there are also
 timing constraints imposed by the peripheral components.
 In particular the VGA controller should operate at 25MHz or 50MHz on account
 of to the VGA signal specification, and the system clock needs to be synchroniz
ed at a multiple of the VGA clock frequency.
 (Note that this limitation is a consequence of the design of the VGA controller
 in the N.I.G.E.
 Machine rather than a limitation of the Xilinx Spartan 3 FPGA device family
 or the VGA specification in general.)
\end_layout

\begin_layout Standard
For the purpose of comparative benchmarking, the 32 bit databus configuration
 N.I.G.E.
 Machine was successfully implemented at 50MHz by reducing the depth of
 SRAM memory to 4K only.
 (By reducing memory depth, the number of Block RAM multiplexers is reduced
 and therefore also the signal time for an SRAM read.
 The saving was enough to compensate).
 However this workaround has limited scope, since whist the benchmarks can
 be run in under 4K of memory, this restriction in memory size is too severe
 for a general purpose microcomputer.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="4cm">
<column alignment="center" valignment="top" width="4cm">
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
N.I.G.E.
 Machine 
\end_layout

\begin_layout Plain Layout

\series bold
(8 bit databus)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
N.I.G.E.
 Machine
\end_layout

\begin_layout Plain Layout

\series bold
(32 bit databus)
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Best achievable timing (ns)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18.22
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22.97
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Equivalent clock frequency (MHz)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
54.89
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
44.84
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Best-achiveable"

\end_inset

Best achievable synthesis and place and route timing for the N.I.G.E.
 Machine on the Nexys 2 development board with a Xilinx XC3S1200E FPGA.
 The 32 bit databus configuration fails to make timing for a 50MHz clock
 speed.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename EF2013 figures/PC update logic.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:PC logic"

\end_inset

Schematic of the longest signal path in the N.I.G.E.
 Machine 32 bit databus configuration that is responsible for limiting the
 best achievable timing to more than 20ns
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Performance benchmarks
\end_layout

\begin_layout Standard
A series of benchmarks were run to compare the performance of the N.I.G.E.
 Machine in both the 8 bit and 32 bit databus configurations at 50MHz.
 The benchmarks were based on a number of standard FORTH tests 
\begin_inset CommandInset citation
LatexCommand cite
key "Benchmarks"

\end_inset

, minimally adapted to run in an embedded environment.
 As a baseline comparison, the benchmarks were also run on a Intel i7 desktop
 PC at 2.8GHz using VFX FORTH.
 Tables 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:benchmarks"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Relative-benchmark"

\end_inset

 show the results.
\end_layout

\begin_layout Standard
The N.I.G.E.
 Machine in 32 bit databus format is on average 14% faster in primitive
 operations and 20% faster in applications than in 8 bit databus format.
 However the speed increase varies according to the application.
 Eratosthenes’s sieve is only 4% faster while the eight queens problem is
 29% faster.
 This is because not all instructions are faster in the 32 bit datapath
 format and so the instruction mix of an application is also important.
\end_layout

\begin_layout Standard
The N.I.G.E.
 Machine in 32 bit databus configuration is approximately 150x slower on
 average than an Intel i7 PC running VFX FORTH, but again the range varies
 from 120x for random numbers to almost 300x for quicksort.
 However the N.I.G.E.
 Machine was clocked at 50MHz while the PC was clocked at 2.8GHz, a difference
 of 56x.
 Allowing for the difference in clock speeds, the N.I.G.E.
 Machine was only 3x slower on average than the PC.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="5">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="3.5cm">
<column alignment="right" valignment="top" width="2cm">
<column alignment="right" valignment="top" width="2.5cm">
<column alignment="right" valignment="top" width="2.5cm">
<column alignment="right" valignment="top" width="2cm">
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Benchmark
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Iterations
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
N.I.G.E.
 Machine
\begin_inset Newline newline
\end_inset

(8 bit bus)
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
N.I.G.E.
 Machine
\begin_inset Newline newline
\end_inset

 (32 bit bus)
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
PC i7
\begin_inset Newline newline
\end_inset

VFX FORTH
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Primitives
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ms
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ms
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ms
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DO LOOP
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,000,000
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
260
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
260
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,000,000
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
340
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
300
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,000,000
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
440
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
420
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,000,000
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,240
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,200
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/MOD
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,000,000
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,240
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,200
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*/
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,000,000
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,420
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,400
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Array fill (1000 items)
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,000,000
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9,008
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7,207
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13,948
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11,987
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Applications
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eratosthenes sieve
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3000
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19,680
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18,884
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
110
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fibonacci recursion
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
44,272
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37,947
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
265
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Quick sort
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,000
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10,924
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9,171
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Random numbers 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,000
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
48,795
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
35,643
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
296
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bubble sort
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
41,089
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
33,387
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
218
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eight queens
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37,774
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
26,968
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
141
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
202,534
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
162,000
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,046
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:benchmarks"

\end_inset

Benchmark timing results for the N.I.G.E.
 Machine in 8 bit and 32 bit datapath configurations, and the same tests
 run on an Intel i7 PC using VFX FORTH.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="4cm">
<column alignment="right" valignment="top" width="3cm">
<column alignment="right" valignment="top" width="3cm">
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Benchmark
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
N.I.G.E.
 Machine (32 bit) / (8 bit)
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
N.I.G.E.
 Machine (32 bit) / PC i7
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
multiple
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eratosthenes sieve
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
96%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
172
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fibonacci recursion
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
86%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
143
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Quick sort
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
84%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
296
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Random numbers
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
73%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bubble sort
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
81%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
153
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eight queens
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
71%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
191
\end_layout

\end_inset
</cell>
</row>
<row topspace="0.05cm" bottomspace="0.05cm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
80%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
155
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Relative-benchmark"

\end_inset

Relative benchmark timing results for the 32 bit datapath format N.I.G.E.
 Machine compared to the 8 bit datapath format N.I.G.E.
 Machine and a PC i7 running VFX FORTH .
 The 32 bit datapath configuration is on average ~20% faster than the 8
 bit configuration.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Standard
At the outset it was expected that the main challenge in widening the memory
 datapath from 8 to 32 bits would be to design appropriate logic to maintain
 deterministic execution, instruction throughput, byte-sized instruction
 format, and flexible memory access.
 Two major components had to be developed to accomplish these objectives.
 Firstly, an SRAM controller that leveraged the dual ported Block RAM available
 on the FPGA.
 Secondly, an adaption to the control unit to facilitate the execution of
 variable length instructions in a single clock cycle.
 
\end_layout

\begin_layout Standard
However these components were included at the expense of additional logic
 levels and a longer signal path.
 This reduced the maximum achievable clock frequency.
 Whilst the 32 bit memory databus configuration completes benchmarking tests
 in approximately 20% less clock cycles than the 8 bit configuration, the
 maximum clock frequency that can be achieved at implementation is also
 roughly 20% less (~40 MHz c.f.
 ~50 MHz) 
\end_layout

\begin_layout Standard
Perhaps in retrospect this tradeoff should have been anticipated.
 It is similar to the tradeoff between the RISC (reduced instruction set
 computing) and CISC (complex instruction set computing) approaches to CPU
 design, and occurs for similar reasons.
 RISC designs utilize less logic but can operate at a higher clock speed
 compared to CISC designs that have more sophisticated instruction set functiona
lity.
\end_layout

\begin_layout Standard
One avenue for further consideration might be to review alternative device
 families to determine whether FPGA's that incorporate Block RAM with a
 byte select feature are available, given the utility that would have with
 a 32 bit databus.
 However, an overarching aim of the N.I.G.E.
 Machine is to use only low-cost, ubiquitous hardware and consequently the
 design preference in general is to work around inherent limitations rather
 than 
\begin_inset Quotes eld
\end_inset

up-spec
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The question is then, which approach is more appropriate for a FORTH softcore
 such as the N.I.G.E.
 Machine? A 
\begin_inset Quotes eld
\end_inset

CISC like
\begin_inset Quotes erd
\end_inset

, 32 bit databus with the ability to execute variable length instructions
 in a single cycle, resulting in instruction execution that completes in
 few clock cycles.
 Or a 
\begin_inset Quotes eld
\end_inset

RISC like
\begin_inset Quotes erd
\end_inset

, 8 bit databus matched to the instruction size with fewer layers of logic,
 resulting in a higher implementable clock frequency?
\end_layout

\begin_layout Standard
The answer to this dilemma may be to look more carefully within the CPU
 at the differing needs of the control unit and the datapath.
 The datapath within the N.I.G.E.
 Machine's softcore CPU is 32 bits wide.
 Matching the 32 bit datapath to a 32 bit memory databus optimizes execution
 speed by maximizing data transfer bandwidth.
 On the other hand, the control unit can operate at a higher clock speed
 when there is no need to execute variable length instructions in a single
 cycle.
 A hybrid design can be envisaged that maintains the 32 bit memory databus
 matched to the 32 bit datapath, but reverts to a control unit that processes
 instructions on a byte-by-byte basis.
 Such a hybrid design might have the following characteristics:
\end_layout

\begin_layout Itemize
Maximum clock speed no slower then the 8 bit databus configuration (i.e.
 50MHz)
\end_layout

\begin_layout Itemize
Fetch/store instructions execute approximately as fast as with the pure
 32 bit databus configuration
\end_layout

\begin_layout Itemize
The fast JSL (jump to subroutine literal address) instruction is included
\end_layout

\begin_layout Itemize
The pipeline could revert to 3 stages, eliminating the extra clock cycle
 restart penalty of the 4 stage pipeline
\end_layout

\begin_layout Itemize
Load literal instructions would have a throughput of less than one instruction
 per clock cycle
\end_layout

\begin_layout Standard
Based on the results discussed above, such a hybrid design is likely to
 prove a better performer than either the pure 8 bit or 32 bit databus configura
tions.
 Development along these lines is an attractive avenue for further work
 on the N.I.G.E.
 Machine.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
This project set out to widen the N.I.G.E.
 Machine's memory databus from 8 bits to 32 bits.
 In doing so it was found that neither configuration is absolutely better
 than the other.
 The tradeoffs between them concern maximizing clock speed versus maximizing
 instruction throughput.
 This result parallels the differences between the RISC and CISC approaches
 to CPU design.
 In the case of the N.I.G.E.
 Machine, a hybrid memory databus that addresses the differing needs of
 the CPU control unit and datapath is likely to be the optimum performance
 strategy.
 Further work will be undertaken on the N.I.G.E.
 Machine to implement such an approach.
\end_layout

\begin_layout Standard
Whilst it is recognized that differing processor designs have differing
 design tradeoffs at a detailed level, some general conclusions about the
 strategy for optimizing memory access design for a 32 bit FORTH processor
 can be drawn from these project results.
 A FORTH processor is likely to be optimized for the efficient execution
 of a basic set of stack and memory operations, subject to embedded control
 objectives such as deterministic execution and high code density.
 Maximum clock speed is achieved with simple control unit logic.
 Given these considerations, it is likely desirable to match the width of
 the memory databus to the control unit to the width of a single instruction
 (8 bits on the N.I.G.E.
 Machine).
 On the other hand, a FORTH processor is a fetch/store architecture and
 so data bandwidth will be maximized by matching the width of the memory
 databus to the width of the CPU datapath (32 bits on the N.I.G.E.
 Machine).
 The best overall approach is therefore likely to adopt a hybrid databus
 design, whereby the needs of the CPU control unit and datapath are separately
 identified and addressed.
\end_layout

\begin_layout Standard
The author would like to thank the anonymous academic reviewers for their
 comments and suggestion, all of which have helped to improve the paper.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Video 1"

\end_inset

The author, 
\begin_inset CommandInset href
LatexCommand href
target "http://www.youtube.com/watch?v=0v-HuVLRoUc"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "EF2012"

\end_inset

The author, 
\begin_inset Quotes eld
\end_inset

The N.I.G.E.
 Machine: an FPGA based micro-computer system for prototyping experimental
 scientific hardware
\begin_inset Quotes erd
\end_inset

, in 
\emph on
EuroForth
\emph default
, 2012
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Bowman"

\end_inset

James Bowman , 
\begin_inset Quotes eld
\end_inset

J1: a small Forth CPU Core for FPGAs
\begin_inset Quotes erd
\end_inset

 in 
\emph on
EuroForth
\emph default
, 2010
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Microcore"

\end_inset

K.
 Schleisiek, “MicroCore,” in 
\emph on
EuroForth
\emph default
, 2001.
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "b16"

\end_inset

B.
 Paysan, “b16-small – Less is More,” in 
\emph on
EuroForth
\emph default
, 2004.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "EP32"

\end_inset

E.
 Hjrtland and L.
 Chen, “EP32 - a 32-bit Forth Microprocessor,” in Canadian Conference on
 Electrical and Computer Engineering, pp.
 518–521, 2007.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Novix NC4000"

\end_inset

E.
 Jennings, “The Novix NC4000 Project,” Computer Language, vol.
 2, no.
 10, pp.
 37–46, 1985.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Rible"

\end_inset

Rible, John, "QS2: RISCing it all," Proceedings of the 1991 FORML Conference,
 Forth Interest Group, Oakland, CA (1991), pp.
 156-159.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Pelc"

\end_inset

Stephen Pelc, 
\begin_inset Quotes eld
\end_inset

Programming FORTH
\begin_inset Quotes erd
\end_inset

, MPE, 2011
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Koopman"

\end_inset

P.
 J.
 Koopman, Jr., 
\begin_inset Quotes eld
\end_inset

Stack computers: the new wave
\begin_inset Quotes erd
\end_inset

, Halsted Press, 1989
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Github"

\end_inset

The author, Github open source repository 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/Anding/N.I.G.E.-Machine"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Benchmarks"

\end_inset

MPE benchmark suite for 32 bit Forth systems, 
\begin_inset CommandInset href
LatexCommand href
target "http://www.mpeforth.com/arena/benchmrk.fth"

\end_inset


\end_layout

\end_body
\end_document
